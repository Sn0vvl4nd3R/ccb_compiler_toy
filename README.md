# CCB Compiler

![Build Status](https://img.shields.io/badge/build-passing-brightgreen)
![License](https://img.shields.io/badge/license-MIT-blue)

**CCB Compiler** — учебный проект, созданный в рамках индивидуальной практики. Его цель — изучить принципы работы компиляторов путём разработки минималистичного, но полнофункционального языка программирования, собственного компилятора и стековой виртуальной машины (ВМ).

Весь проект написан «с нуля» на C, что позволяет глубже понять управление памятью, структуры данных и алгоритмы, лежащие в основе средств разработки.

---

## Содержание

* [О языке CCB](#о-языке-ccb)
* [Основные возможности](#основные-возможности)
* [Примеры программ](#примеры-программ)
* [Архитектура компилятора](#архитектура-компилятора)
* [Сборка и запуск](#сборка-и-запуск)
* [Contributing](#contributing)
* [Лицензия](#лицензия)
* [Контакты](#контакты)

---

## О языке CCB

**CCB** — минималистичный императивный язык. Синтаксис сконцентрирован на ключевых этапах компиляции, поэтому он содержит лишь необходимый набор конструкций.

### Основные возможности

| Категория               | Поддержка                                                                    |
| ----------------------- | ---------------------------------------------------------------------------- |
| Переменные              | `let` и оператор присваивания `=`                                            |
| Области видимости       | **Глобальные** (на верхнем уровне) и **локальные** (внутри `fn`)             |
| Типы данных             | `int` (целые числа)                                                          |
| Арифметика              | `+`, `-`, `*`, `/`                                                           |
| Сравнения               | `<`, `>`, `<=`, `>=`, `==`, `!=`                                             |
| Управляющие конструкции | `if { ... } else { ... }`, `while (cond) { ... }`                            |
| Функции                 | `fn name(param1, param2, ...) -> int { ... }`, оператор `return expr;`       |
| Пространства имён       | `ns name { ... }`, вложенные: обращение по `a.b.c.symbol`                    |
| Вызовы функций          | `foo(arg1, arg2)`, квалифицированные: `ns1.ns2.foo(...)`                     |
| Ввод / вывод            | `in ident;` (в глобал или **предварительно объявленный** локал), `out expr;` |
| Идентификаторы          | шаблон `[A-Za-z_][A-Za-z0-9_]*` (например, `sum3`, `mul2`, `_tmp`)           |
| Комментарии             | однострочные `// ...`                                                        |

> Примечание: локальная переменная создается только через `let` внутри функции. Ввод в локальную переменную допустим после ее объявления:
>
> ```ccb
> fn read() -> int { let x = 0; in x; return x; }
> ```

---

## Примеры программ

### 1) Классика: Фибоначчи

```ccb
let limit = 10;
let count = 0;

let a = 0;
let b = 1;

while (count < limit) {
  out a;
  let next = a + b;
  a = b;
  b = next;
  count = count + 1;
}
```

### 2) Namespaces, функции с параметрами и локалами

```ccb
ns math {
  ns arith {
    fn mul2(x) -> int { return x * 2; }
  }
  fn sum3(a, b, c) -> int {
    let t = a + b;
    return t + c;
  }
}

out math.arith.mul2(10);   // 20
out math.sum3(1, 2, 3);    // 6
```

Больше примеров — в каталоге [`examples/`](./examples/).

---

## Архитектура компилятора

```text
Исходник (.ccb)
   │
   ▼
[Лексер]        — поток токенов
   │
   ▼
[Парсер]        — AST
   │
   ▼
[Кодогенератор] — байткод
   │
   ▼
[Стековая ВМ]   — выполнение
```

* **Лексер**: разбивает исходный текст на токены (идентификаторы по `[A-Za-z_][A-Za-z0-9_]*`, поддержка `//`-комментариев).
* **Парсер**: рекурсивный спуск + Pratt-парсинг выражений; поддержка `ns`, `fn` (с параметрами), `return`, вызовов с аргументами.
* **Кодогенератор**: обходит AST и эмитирует байткод. Введены инструкции для локалов (`OP_GET_LOCAL`, `OP_SET_LOCAL`, `OP_IN_LOCAL`) и вызовов (`OP_CALL`).
* **Виртуальная машина**: стековая, с кадровым стеком вызовов (адрес возврата + база кадра). Локалы и параметры — слоты относительно базы кадра; `return` сворачивает кадр и оставляет значение на стеке.

---

## Сборка и запуск

### Требования

* **C-компилятор**: GCC ≥ 10 или Clang ≥ 12
* **Make**

### Сборка

```bash
# в корневой директории проекта
make
```

После сборки появятся:

* `./bin/compiler` — исполняемый файл компилятора/ВМ
* `./obj/` — объектные файлы

### Запуск программы

```bash
./bin/compiler examples/fibonacci.ccb
```

Файлы исходников должны иметь расширение **`.ccb`**.

### Полезные цели Makefile

| Цель         | Действие                                   |
| ------------ | ------------------------------------------ |
| `make`       | Полная сборка                              |
| `make clean` | Удалить `bin/` и `obj/`                    |
| `make test`  | Собрать и запустить примеры из `examples/` |

---

## Лицензия

Проект лицензирован под лицензией **MIT**. См. файл [`LICENSE`](./LICENSE).

---

## Контакты

* **Автор**: [Nikita Vasilev](https://github.com/Sn0vvl4nd3R)
* [Резюме на hh.ru](https://hh.ru/resume/93e51b7dff0efd6fda0039ed1f506571426941)
* [Резюме на SuperJob](https://www.superjob.ru/resume/razrabotchik-c-55732969.html)
